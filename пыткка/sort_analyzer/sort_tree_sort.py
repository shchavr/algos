def sort_tree_sort(arr):
    """Сортировка с помощью дерева поиска (BST)."""
    
    comparisons = 0  

    class Node:
        """Класс для узла бинарного дерева поиска."""
        def __init__(self, data):
            self.data = data  # Данные, хранящиеся в узле
            self.left = None  # Указатель на левое поддерево
            self.right = None  # Указатель на правое поддерево

    root = None  # Изначально корень дерева пуст
    nodes_count = 0  # Счетчик общего количества узлов

    # Итеративная вставка узлов в дерево
    for data in arr:
        nodes_count += 1  # Увеличиваем счетчик узлов
        new_node = Node(data)  # Создаем новый узел с текущими данными

        # Если дерево пустое, новый узел становится корнем
        if root is None:
            root = new_node
            
        else:
            curr = root  # Текущий узел, начинаем с корня
            
            while True:  # Цикл продолжается, пока не найдем место для нового узла
                comparisons += 1  # Учитываем сравнение при каждом шаге поиска места
                
                if data < curr.data:  # Если данные меньше, идем в левое поддерево
                    
                    if curr.left is None:  # Если общее поддерево пустое, вставляем новый узел
                        curr.left = new_node
                        break 
                    
                    else:
                        curr = curr.left  # Переходим к левому узлу
                        
                else:  # Если данные больше или равны, идем в правое поддерево
                    
                    if curr.right is None:  # Если правое поддерево пустое, вставляем новый узел
                        curr.right = new_node
                        break  
                    
                    else:
                        curr = curr.right  # Переходим к правому узлу

    # Итеративный обход дерева для получения отсортированного списка
    sorted_arr = []  # Список для хранения отсортированных данных
    stack = []  # Используем стек для хранения узлов во время обхода
    curr = root  # Начинаем с корня дерева

    while curr or stack:  # Продолжаем, пока есть элементы для обхода
        # идем до самого левого узла
        while curr:
            stack.append(curr)  # Добавляем текущий узел в стек
            curr = curr.left  # Переходим к левому поддереву

        curr = stack.pop()  # Возвращаемся к предыдущему узлу из стека
        sorted_arr.append(curr.data)  # Добавляем его значение в отсортированный список
        curr = curr.right  # Переходим к правому поддереву, если оно существует

    return sorted_arr, comparisons  
