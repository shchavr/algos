def merge_sort(arr):
    """Сортировка слиянием."""
    # Используем список для хранения количества сравнений
    comparisons = [0]  

    # Вспомогательная функция для слияния двух отсортированных подмассивов
    def merge(arr, l, m, r):
        # Создаем временные массивы для левой и правой подчастей
        L = arr[l:m + 1] 
        R = arr[m + 1:r + 1]  

        # Индексы для отслеживания позиции в подмассивах и в основном массиве
        i = j = 0  # Индексы для L и R
        k = l      # Индекс для основного массива

        # Слияние двух подмассивов в отсортированном порядке
        while i < len(L) and j < len(R):
            comparisons[0] += 1  
            if L[i] <= R[j]:  
                arr[k] = L[i]  # Помещаем элемент из L в основной массив
                i += 1  # Переходим к следующему элементу в L
            else:
                arr[k] = R[j]  # Иначе помещаем элемент из R
                j += 1  # Переходим к следующему элементу в R
            k += 1  

        # Копирование оставшихся элементов из L, если они есть
        while i < len(L):
            arr[k] = L[i]  # Копируем элемент из L в основной массив
            i += 1  # Переходим к следующему элементу в L
            k += 1  # Увеличиваем индекс для основного массива

        # Копирование оставшихся элементов из R, если они есть
        while j < len(R):
            arr[k] = R[j]  
            j += 1  
            k += 1 

    # Рекурсивная функция сортировки
    def merge_sort_recursive(arr, l, r):
        if l < r:  # Если существует более одного элемента для сортировки
            # Находим средний индекс
            m = l + (r - l) // 2
            # Рекурсивно сортируем левую и правую части массива
            merge_sort_recursive(arr, l, m)
            merge_sort_recursive(arr, m + 1, r)
            # Сливаем отсортированные подмассивы
            merge(arr, l, m, r)

    merge_sort_recursive(arr, 0, len(arr) - 1)
    return arr, comparisons[0]
